# ...existing code...
name: CI/CD - FastAPI Deployment

on:
  push:
    branches:
      - feature/devops-platform
  workflow_dispatch:
    inputs:
      ssh_key:
        description: 'Private SSH key (full content). Only used to create missing secret when running manually.'
        required: false
      vm_ip:
        description: 'VM IP (used to create missing secret when running manually)'
        required: false
      ssh_user:
        description: 'SSH user (used to create missing secret when running manually)'
        required: false

permissions:
  contents: read
  actions: write
  secrets: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: deploy-${{ github.ref }}
      cancel-in-progress: true

    env:
      REPO_PATH: /home/azureuser/enterprise-devops-ml-platform
      BRANCH: feature/devops-platform
      MAX_HEALTH_RETRIES: 15
      HEALTH_SLEEP_SEC: 2

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Fail if repo contains inline private key
        run: |
          if grep -R --line-number "BEGIN OPENSSH PRIVATE KEY" --exclude-dir=.git . >/dev/null 2>&1; then
            echo "ERROR: Found an inline private key in the repository. Remove it and purge history before continuing." >&2
            exit 1
          fi

      - name: Check existing repo secrets
        id: check_secrets
        uses: actions/github-script@v6
        with:
          script: |
            const core = require('@actions/core');
            const repo = context.repo;
            for (const name of ['SSH_KEY','VM_IP','SSH_USER']) {
              try {
                await github.request('GET /repos/{owner}/{repo}/actions/secrets/{secret_name}', {
                  owner: repo.owner,
                  repo: repo.repo,
                  secret_name: name
                });
                core.setOutput(name.toLowerCase() + '_present', 'true');
              } catch (e) {
                core.setOutput(name.toLowerCase() + '_present', 'false');
              }
            }

      - name: Create SSH_KEY from input (if missing)
        if: ${{ steps.check_secrets.outputs.ssh_key_present == 'false' && github.event_name == 'workflow_dispatch' && github.event.inputs.ssh_key != '' }}
        uses: peter-evans/create-or-update-secret@v4
        with:
          secret-name: SSH_KEY
          secret-value: ${{ github.event.inputs.ssh_key }}

      - name: Create VM_IP from input (if missing)
        if: ${{ steps.check_secrets.outputs.vm_ip_present == 'false' && github.event_name == 'workflow_dispatch' && github.event.inputs.vm_ip != '' }}
        uses: peter-evans/create-or-update-secret@v4
        with:
          secret-name: VM_IP
          secret-value: ${{ github.event.inputs.vm_ip }}

      - name: Create SSH_USER from input (if missing)
        if: ${{ steps.check_secrets.outputs.ssh_user_present == 'false' && github.event_name == 'workflow_dispatch' && github.event.inputs.ssh_user != '' }}
        uses: peter-evans/create-or-update-secret@v4
        with:
          secret-name: SSH_USER
          secret-value: ${{ github.event.inputs.ssh_user }}

      - name: Ensure required secrets exist
        run: |
          if [ -z "${{ secrets.SSH_KEY }}" ] || [ -z "${{ secrets.VM_IP }}" ] || [ -z "${{ secrets.SSH_USER }}" ]; then
            echo "Missing required secrets. Add them in Settings â†’ Secrets, or re-run this workflow with inputs (Run workflow) to create them automatically." >&2
            echo "Missing status: SSH_KEY=${{ secrets.SSH_KEY != '' }}, VM_IP=${{ secrets.VM_IP != '' }}, SSH_USER=${{ secrets.SSH_USER != '' }}" >&2
            exit 1
          fi

      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.9.1
        with:
          ssh-private-key: ${{ secrets.SSH_KEY }}

      - name: Deploy to VM
        env:
          VM_IP: ${{ secrets.VM_IP }}
          SSH_USER: ${{ secrets.SSH_USER }}
        run: |
          echo "Connecting to VM and running remote deployment..."
          ssh -o StrictHostKeyChecking=no "$SSH_USER@$VM_IP" <<'REMOTE'
            set -euo pipefail
            cd "$REPO_PATH"

            echo "Resetting to remote branch..."
            git fetch origin --depth=1
            git reset --hard origin/$BRANCH

            if command -v lsof >/dev/null 2>&1; then
              PID=$(lsof -ti:8000 || true)
              if [ -n "$PID" ]; then
                echo "Killing process(es) on port 8000: $PID"
                kill -9 $PID || true
              fi
            else
              echo "lsof not present; skipping port kill."
            fi

            docker-compose down || true
            docker-compose up -d --build

            if [ -f deployment.sh ]; then
              chmod +x deployment.sh
              ./deployment.sh || true
            else
              echo "No deployment.sh found, skipping."
            fi
          REMOTE

      - name: Confirm deployment (health check)
        env:
          VM_IP: ${{ secrets.VM_IP }}
        run: |
          echo "Waiting for API to become healthy..."
          for i in $(seq 1 $MAX_HEALTH_RETRIES); do
            if curl -fsS http://$VM_IP:8000/health >/dev/null 2>&1; then
              echo "âœ… API is healthy (attempt $i)"
              exit 0
            fi
            echo "â³ attempt $i/$MAX_HEALTH_RETRIES - waiting $HEALTH_SLEEP_SEC seconds..."
            sleep $HEALTH_SLEEP_SEC
          done
          echo "âŒ Health check failed after $MAX_HEALTH_RETRIES retries" >&2
          exit 1

      - name: Deployment complete
        run: echo "ðŸŽ‰ Deployment finished."
# ...existing code...
